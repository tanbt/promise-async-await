<!DOCTYPE html>
<html>
  <head>
    <!-- Replace these file with absolute URLs when embedding this html file to Google Slides -->
    <script src="main.js" async></script>
    <link rel="stylesheet" href="styles.css">
    <script src="custom.js" async></script>
    <link rel="stylesheet" href="custom.css">
  </head>
  <body>

<div class="container">
  <div class="content-n-side">
    <div class="content">
      <script>
  document.title = 'Tasks, microtasks, queues and schedules - JakeArchibald.com';
</script>

<div class="article-content">
  <h1>Tasks, microtasks, queues and schedules</h1>
  <time class="article-date" datetime="2015-08-17">
    Posted 17 August 2015
    
    - hold onto your butts for this one, it&#39;s spec-heavy
    
  </time>
  
  <p>When I told my colleague <a href="https://twitter.com/gauntface">Matt Gaunt</a> I was thinking of writing a piece on microtask queueing and execution within the browser's event loop, he said "I'll be honest with you Jake, I'm not going to read that". Well, I've written it anyway, so we're all going to sit here and enjoy it, ok?</p>
<p>Actually, if video's more your thing, <a href="https://twitter.com/philip_roberts">Philip Roberts</a> gave a <a href="https://www.youtube.com/watch?v=8aGhZQkoFbQ">great talk at JSConf on the event loop</a> - microtasks aren't covered, but it's a great introduction to the rest. Anyway, on with the show…</p>
<p>Take this little bit of JavaScript:</p>
<div class="codehilite"><pre><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;script start&#39;</span><span class="p">);</span>

<span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;setTimeout&#39;</span><span class="p">);</span>
<span class="p">},</span> <span class="mi">0</span><span class="p">);</span>

<span class="nx">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">().</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;promise1&#39;</span><span class="p">);</span>
<span class="p">}).</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;promise2&#39;</span><span class="p">);</span>
<span class="p">});</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;script end&#39;</span><span class="p">);</span>
</pre></div>


<p>In what order should the logs appear?</p>
<h2 id="try-it">Try it</h2>
<p><button class="btn clear-log-1">Clear log</button> <button class="btn test-1">Run test</button></p>
<style>
.log-output {
  width: 100%;
  box-sizing: border-box;
  height: 12.7rem;
  font: inherit;
  line-height: 1.5;
}
</style>

<p><textarea class="log-output log-output-1" readonly></textarea></p>
<script>
function log1(str) {
  console.log(str);
  var logEl = document.querySelector('.log-output-1');
  logEl.value += (logEl.value ? '\n' : '') + str;
}

document.querySelector('.clear-log-1').addEventListener('click', function() {
  document.querySelector('.log-output-1').value = '';
});

document.querySelector('.test-1').addEventListener('click', function() {
  log1('script start');

  setTimeout(function() {
    log1('setTimeout');
  }, 0);

  Promise.resolve().then(function() {
    log1('promise1');
  }).then(function() {
    log1('promise2');
  });

  log1('script end');
});
</script>

<p>The correct answer: <code>script start</code>, <code>script end</code>, <code>promise1</code>, <code>promise2</code>, <code>setTimeout</code>, but it's pretty wild out there in terms of browser support.</p>
<p>Microsoft Edge, Firefox 40, iOS Safari and desktop Safari 8.0.8 log <code>setTimeout</code> before <code>promise1</code> and <code>promise2</code> - although it appears to be a race condition. This is really weird, as Firefox 39 and Safari 8.0.7 get it consistently right.</p>
<h2 id="why-this-happens">Why this happens</h2>
<p>To understand this you need to know how the event loop handles tasks and microtasks. This can be a lot to get your head around the first time you encounter it. Deep breath…</p>
<p>Each 'thread' gets its own <strong>event loop</strong>, so each web worker gets its own, so it can execute independently, whereas all windows on the same origin share an event loop as they can synchronously communicate. The event loop runs continually, executing any tasks queued. An event loop has multiple task sources which guarantees execution order within that source (specs <a href="https://w3c.github.io/IndexedDB/#database-access-task-source">such as IndexedDB</a> define their own), but the browser gets to pick which source to take a task from on each turn of the loop. This allows the browser to give preference to performance sensitive tasks such as user-input. Ok ok, stay with me…</p>
<p><strong>Tasks</strong> are scheduled so the browser can get from its internals into JavaScript/DOM land and ensures these actions happen sequentially. Between tasks, the browser <em>may</em> render updates. Getting from a mouse click to an event callback requires scheduling a task, as does parsing HTML, and in the above example, <code>setTimeout</code>.</p>
<p><code>setTimeout</code> waits for a given delay then schedules a new task for its callback. This is why <code>setTimeout</code> is logged after <code>script end</code>, as logging <code>script end</code> is part of the first task, and <code>setTimeout</code> is logged in a separate task. Right, we're almost through this, but I need you to stay strong for this next bit…</p>
<p><strong>Microtasks</strong> are usually scheduled for things that should happen straight after the currently executing script, such as reacting to a batch of actions, or to make something async without taking the penalty of a whole new task. The microtask queue is processed after callbacks as long as no other JavaScript is mid-execution, and at the end of each task. Any additional microtasks queued during microtasks are added to the end of the queue and also processed. Microtasks include mutation observer callbacks, and as in the above example, promise callbacks.</p>
<p>Once a promise settles, or if it has already settled, it queues a <em>microtask</em> for its reactionary callbacks. This ensures promise callbacks are async even if the promise has already settled. So calling <code>.then(yey, nay)</code> against a settled promise immediately queues a microtask. This is why <code>promise1</code> and <code>promise2</code> are logged after <code>script end</code>, as the currently running script must finish before microtasks are handled. <code>promise1</code> and <code>promise2</code> are logged before <code>setTimeout</code>, as microtasks always happen before the next task.</p>
<p>So, step by step:</p>


<div class="event-loop-walkthrough event-loop-walkthrough-1">
  <div class="js-source">
    <div class="line-highlight"></div>
<div class="codehilite"><pre><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'script start'</span><span class="p">);</span>

<span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'setTimeout'</span><span class="p">);</span>
<span class="p">},</span> <span class="mi">0</span><span class="p">);</span>

<span class="nx">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">().</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'promise1'</span><span class="p">);</span>
<span class="p">}).</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'promise2'</span><span class="p">);</span>
<span class="p">});</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'script end'</span><span class="p">);</span>
</pre></div>

<p></div>
  <table>
    <tr class="task-queue">
      <th>Tasks</th>
      <td>
        <div class="event-loop-items">
          <div class="event-loop-rail">
            <div class="event-loop-item">Run script</div>
            <div class="event-loop-item">setTimeout callback</div>
          </div>
        </div>
      </td>
    </tr>
    <tr class="microtask-queue">
      <th>Microtasks</th>
      <td>
        <div class="event-loop-items">
          <div class="event-loop-rail">
            <div class="event-loop-item">Promise then</div>
            <div class="event-loop-item">Promise then</div>
          </div>
        </div>
      </td>
    </tr>
    <tr class="js-stack">
      <th>JS stack</th>
      <td>
        <div class="event-loop-items"></div>
      </td>
    </tr>
    <tr class="event-loop-log">
      <th>Log</th>
      <td>
        <div class="event-loop-items">
          <div class="event-loop-item">script start</div>
          <div class="event-loop-item">script end</div>
          <div class="event-loop-item">promise1</div>
          <div class="event-loop-item">promise2</div>
          <div class="event-loop-item">setTimeout</div>
        </div>
      </td>
    </tr>
  </table>
  <div class="event-loop-controls">
    <svg viewBox="0 0 5 2">
      <path d="M2,0 L2,2 L0,1 z" />
      <path d="M3,0 L5,1 L3,2 z" />
      <path class="prev-btn" d="M0,0 H2.5V2H0z" />
      <path class="next-btn" d="M2.5,0 H5V2H2.5z" />
    </svg>
  </div>
  <div class="event-loop-commentary">
    <div class="event-loop-commentary-item"></div>
  </div>
</div></p>
<script>
(function() {
  function transition(el, obj, duration, easing) {
    return new Promise(function(resolve, reject) {
      if (obj.transform) {
        obj['-webkit-transform'] = obj.transform;
      }

      var objKeys = Object.keys(obj);

      if (duration) {
        el.style.transitionProperty = objKeys.join();
        el.style.transitionTimingFunction = easing;
        el.style.transitionDuration = duration + 's';
        el.offsetLeft; // style recalc

        el.addEventListener('transitionend', function te() {
          el.style.transitionProperty = '';
          el.style.transitionTimingFunction = '';
          el.style.transitionDuration = '';
          resolve();
          el.removeEventListener('transitionend', te);
        });
      }
      else {
        resolve();
      }

      objKeys.forEach(function(key) {
        el.style.setProperty(key, obj[key]);
      });
    });
  }

  function EventLoopAnimation(el) {
    this._initalState = el;
    this._states = [];
    this._el = el;
    this._queue = Promise.resolve();
    this._reset();
  }

  EventLoopAnimation.prototype._reset = function() {
    var newEl = this._initalState.cloneNode(true);
    this._tasksShown = 0;
    this._microtasksShown = 0;
    this._tasksRemoved = 0;
    this._microtasksRemoved = 0;
    this._logsShown = 0;
    this._currentPos = 0;

    this._el.parentNode.insertBefore(newEl, this._el);
    this._el.parentNode.removeChild(this._el);
    this._el = newEl;
    this._taskRail = this._el.querySelector('.task-queue .event-loop-rail');
    this._microtaskRail = this._el.querySelector('.microtask-queue .event-loop-rail');
    this._jsStack = this._el.querySelector('.js-stack .event-loop-items');
    this._log = this._el.querySelector('.event-loop-log .event-loop-items');
    this._codeBar = this._el.querySelector('.line-highlight');
    this._codePane = this._el.querySelector('.codehilite');
    this._commentary = this._el.querySelector('.event-loop-commentary-item');

    var onClick = function(event) {
      var className = event.target.getAttribute('class');
      if (className === 'prev-btn') {
        event.preventDefault();
        if (event.type == 'click') {
          this.back();
        }
      }
      else if (className === 'next-btn') {
        event.preventDefault();
        if (event.type == 'click') {
          this.forward(true);
        }
      }
    }.bind(this);

    this._el.addEventListener('click', onClick);
    this._el.addEventListener('mousedown', onClick);
  };

  EventLoopAnimation.prototype.forward = function(animate) {
    this._queue = this._queue.then(function() {
      var state = this._states[this._currentPos];
      if (!state) return this.goTo(0);
      this._currentPos++;
      return Promise.all(
        state.map(function(func) {
          return func(animate);
        })
      );
    }.bind(this));
  };

  EventLoopAnimation.prototype.goTo = function(pos) {
    this._queue = this._queue.then(function() {
      this._reset();
      while (pos--) {
        this.forward(false);
      }
    }.bind(this));
  };

  EventLoopAnimation.prototype.back = function() {
    this._queue = this._queue.then(function() {
      if (this._currentPos === 0) return this.goTo(this._states.length);
      return this.goTo(this._currentPos - 1);
    }.bind(this));
  };

  EventLoopAnimation.prototype.state = function() {
    this._states.push([]);
    return this;
  };

  EventLoopAnimation.prototype.action = function(func) {
    this._states[this._states.length - 1].push(func);
    return this;
  };

  EventLoopAnimation.prototype.pushTask = function(activated) {
    return this.action(function(animate) {
      var newTask = this._taskRail.children[this._tasksShown];
      this._tasksShown++;

      if (activated) {
        newTask.style.backgroundColor = '#FFDF1E';
      }

      return transition(newTask, {
        opacity: 1
      }, 0.2 * animate, 'ease-in-out');
    }.bind(this));
  };

  EventLoopAnimation.prototype.pushMicrotask = function() {
    return this.action(function(animate) {
      var newTask = this._microtaskRail.children[this._microtasksShown];
      this._microtasksShown++;

      return transition(newTask, {
        opacity: 1
      }, 0.2 * animate, 'ease-in-out');
    }.bind(this));
  };

  EventLoopAnimation.prototype.pushStack = function(text) {
    return this.action(function(animate) {
      var div = document.createElement('div');
      div.className = 'event-loop-item';
      div.textContent = text;
      div.style.backgroundColor = '#FFDF1E';
      this._jsStack.appendChild(div);
      return transition(div, {
        opacity: 1
      }, 0.2 * animate, 'ease-in-out');
    }.bind(this));
  };

  EventLoopAnimation.prototype.popStack = function(text) {
    return this.action(function(animate) {
      var div = this._jsStack.children[this._jsStack.children.length - 1];
      return transition(div, {
        opacity: 0
      }, 0.2 * animate, 'ease-in-out').then(function() {
        this._jsStack.removeChild(div);
      }.bind(this));
    }.bind(this));
  };

  EventLoopAnimation.prototype.showCodeBar = function() {
    return this.action(function(animate) {
      return transition(this._codeBar, {
        opacity: 1
      }, 0.2 * animate, 'ease-in-out');
    }.bind(this));
  };

  EventLoopAnimation.prototype.hideCodeBar = function() {
    return this.action(function(animate) {
      return transition(this._codeBar, {
        opacity: 0
      }, 0.2 * animate, 'ease-in-out');
    }.bind(this));
  };

  EventLoopAnimation.prototype.pushLog = function() {
    return this.action(function(animate) {
      var newLog = this._log.children[this._logsShown];
      this._logsShown++;

      return transition(newLog, {
        opacity: 1
      }, 0.2 * animate, 'ease-in-out');
    }.bind(this));
  };

  EventLoopAnimation.prototype.moveToLine = function(num) {
    return this.action(function(animate) {
      var barHeight = this._codeBar.getBoundingClientRect().height;

      return transition(this._codePane, {
        transform: 'translateY(' + ((num-1) * -barHeight) + 'px)'
      }, 0.3 * animate, 'ease-in-out');
    }.bind(this));
  };

  EventLoopAnimation.prototype.commentary = function(text) {
    return this.action(function(animate) {
      this._commentary.textContent = text;
      return transition(this._commentary, {
        opacity: 1
      }, 0.2 * animate, 'ease-in-out');
    }.bind(this));
  };

  EventLoopAnimation.prototype.hideCommentary = function() {
    return this.action(function(animate) {
      return transition(this._commentary, {
        opacity: 0
      }, 0.2 * animate, 'ease-in-out');
    }.bind(this));
  };

  EventLoopAnimation.prototype.activateMicrotask = function() {
    return this.action(function(animate) {
      var div = this._microtaskRail.children[this._microtasksRemoved];
      return transition(div, {
        'background-color': '#FFDF1E'
      }, 0.2 * animate, 'ease-in-out');
    }.bind(this));
  };

  EventLoopAnimation.prototype.shiftMicrotask = function() {
    return this.action(function(animate) {
      this._microtasksRemoved++;
      var offset;
      var offsetEl = this._microtaskRail.children[this._microtasksRemoved];

      if (offsetEl) {
        offset = offsetEl.offsetLeft;
      }
      else {
        offset = this._microtaskRail.offsetWidth;
      }

      return transition(this._microtaskRail, {
        'transform': 'translateX(' + (-offset) + 'px)'
      }, 0.3 * animate, 'ease-in-out');
    }.bind(this));
  };

  EventLoopAnimation.prototype.activateTask = function() {
    return this.action(function(animate) {
      var div = this._taskRail.children[this._tasksRemoved];
      return transition(div, {
        'background-color': '#FFDF1E'
      }, 0.2 * animate, 'ease-in-out');
    }.bind(this));
  };

  EventLoopAnimation.prototype.shiftTask = function() {
    return this.action(function(animate) {
      this._tasksRemoved++;
      var offset;
      var offsetEl = this._taskRail.children[this._tasksRemoved];

      if (offsetEl) {
        offset = offsetEl.offsetLeft;
      }
      else {
        offset = this._taskRail.offsetWidth;
      }

      return transition(this._taskRail, {
        'transform': 'translateX(' + (-offset) + 'px)'
      }, 0.3 * animate, 'ease-in-out');
    }.bind(this));
  };

  window.EventLoopAnimation = EventLoopAnimation;
}());

new EventLoopAnimation(document.querySelector('.event-loop-walkthrough-1'))
  .state().moveToLine(1).pushTask(true).pushStack('script').showCodeBar()
  .state().pushLog()
  .state().moveToLine(3)
  .state().commentary("setTimeout callbacks are queued as tasks")
  .state().hideCommentary().pushTask()
  .state().moveToLine(7)
  .state().commentary("Promise callbacks are queued as microtasks")
  .state().hideCommentary().pushMicrotask()
  .state().moveToLine(13)
  .state().pushLog()
  .state().hideCodeBar().popStack()
  .state().commentary("At the end of a task, we process microtasks")
  .state().hideCommentary().activateMicrotask()
  .state().showCodeBar().moveToLine(8).pushStack('Promise callback')
  .state().pushLog()
  .state().hideCodeBar().commentary("This promise callback returns 'undefined', which queues the next promise callback as a microtask")
  .state().hideCommentary().pushMicrotask()
  .state().popStack().commentary("This microtask is done so we move onto the next one in the queue")
  .state().hideCommentary()
  .state().shiftMicrotask().activateMicrotask()
  .state().showCodeBar().moveToLine(10).pushStack('Promise callback')
  .state().pushLog()
  .state().hideCodeBar().popStack().shiftMicrotask()
  .state().commentary("And that's this task done! The browser may update rendering")
  .state().hideCommentary()
  .state().shiftTask().activateTask()
  .state().showCodeBar().moveToLine(4).pushStack('setTimeout callback')
  .state().pushLog()
  .state().hideCodeBar().popStack()
  .state().shiftTask()
  .state().commentary('fin')
  ;
</script>

<p>Yes that's right, I created an animated step-by-step diagram. How did you spend <em>your</em> Saturday? Went out in the <em>sun</em> with your <em>friends</em>? Well <em>I didn't</em>. Um, in case it isn't clear from my amazing UI design, click the arrows above to advance.</p>
<h3 id="what-are-some-browsers-doing-differently">What are some browsers doing differently?</h3>
<p>Some browsers log <code>script start</code>, <code>script end</code>, <code>setTimeout</code>, <code>promise1</code>, <code>promise2</code>. They're running promise callbacks after <code>setTimeout</code>. It's likely that they're calling promise callbacks as part of a new task rather than as a microtask.</p>
<p>This is sort-of excusable, as promises come from ECMAScript rather than HTML. ECMAScript has the concept of "jobs" which are similar to microtasks, but the relationship isn't explicit aside from <a href="https://esdiscuss.org/topic/the-initialization-steps-for-web-browsers#content-16">vague mailing list discussions</a>. However, the general consensus is that promises should be part of the microtask queue, and for good reason.</p>
<p>Treating promises as tasks leads to performance problems, as callbacks may be unnecessarily delayed by task-related things such as rendering. It also causes non-determinism due to interaction with other task sources, and can break interactions with other APIs, but more on that later.</p>
<p>Here's <a href="https://connect.microsoft.com/IE/feedback/details/1658365">an Edge ticket</a> for making promises use microtasks. WebKit nightly is doing the right thing, so I assume Safari will pick up the fix eventually, and it appears to be fixed in Firefox 43.</p>
<p>Really interesting that both Safari and Firefox suffered a regression here that's since been fixed. I wonder if it's just a coincidence.</p>
<h2 id="how-to-tell-if-something-uses-tasks-or-microtasks">How to tell if something uses tasks or microtasks</h2>
<p>Testing is one way. See when logs appear relative to promises &amp; <code>setTimeout</code>, although you're relying on the implementation to be correct.</p>
<p>The certain way, is to look up the spec. For instance, <a href="https://html.spec.whatwg.org/multipage/webappapis.html#timer-initialisation-steps">step 14 of <code>setTimeout</code></a> queues a task, whereas <a href="https://dom.spec.whatwg.org/#queue-a-mutation-record">step 5 of queuing a mutation record</a> queues a microtask.</p>
<p>As mentioned, in ECMAScript land, they call microtasks "jobs". In <a href="https://www.ecma-international.org/ecma-262/6.0/#sec-performpromisethen">step 8.a of <code>PerformPromiseThen</code></a>, <code>EnqueueJob</code> is called to queue a microtask.</p>
<p>Now, let's look at a more complicated example. <em>Cut to a concerned apprentice</em> "No, they're not ready!". Ignore him, you're ready. Let's do this…</p>
<h2 id="level-1-bossfight">Level 1 bossfight</h2>
<p>Before writing this post I'd have gotten this wrong. Here's a bit of html:</p>
<div class="codehilite"><pre><span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">&quot;outer&quot;</span><span class="nt">&gt;</span>
  <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">&quot;inner&quot;</span><span class="nt">&gt;&lt;/div&gt;</span>
<span class="nt">&lt;/div&gt;</span>
</pre></div>


<p>Given the following JS, what will be logged if I click <code>div.inner</code>?</p>
<div class="codehilite"><pre><span class="c1">// Let&#39;s get hold of those elements</span>
<span class="kd">var</span> <span class="nx">outer</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="s1">&#39;.outer&#39;</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">inner</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="s1">&#39;.inner&#39;</span><span class="p">);</span>

<span class="c1">// Let&#39;s listen for attribute changes on the</span>
<span class="c1">// outer element</span>
<span class="k">new</span> <span class="nx">MutationObserver</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;mutate&#39;</span><span class="p">);</span>
<span class="p">}).</span><span class="nx">observe</span><span class="p">(</span><span class="nx">outer</span><span class="p">,</span> <span class="p">{</span>
  <span class="nx">attributes</span><span class="o">:</span> <span class="kc">true</span>
<span class="p">});</span>

<span class="c1">// Here&#39;s a click listener…</span>
<span class="kd">function</span> <span class="nx">onClick</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;click&#39;</span><span class="p">);</span>

  <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;timeout&#39;</span><span class="p">);</span>
  <span class="p">},</span> <span class="mi">0</span><span class="p">);</span>

  <span class="nx">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">().</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;promise&#39;</span><span class="p">);</span>
  <span class="p">});</span>

  <span class="nx">outer</span><span class="p">.</span><span class="nx">setAttribute</span><span class="p">(</span><span class="s1">&#39;data-random&#39;</span><span class="p">,</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">random</span><span class="p">());</span>
<span class="p">}</span>

<span class="c1">// …which we&#39;ll attach to both elements</span>
<span class="nx">inner</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s1">&#39;click&#39;</span><span class="p">,</span> <span class="nx">onClick</span><span class="p">);</span>
<span class="nx">outer</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s1">&#39;click&#39;</span><span class="p">,</span> <span class="nx">onClick</span><span class="p">);</span>
</pre></div>


<p>Go on, give it a go before peeking at the answer. <em>Clue:</em> Logs can happen more than once.</p>
<h2 id="test-it">Test it</h2>
<p>Click the inner square to trigger a click event:</p>
<style>
.outer-test {
  background: #D4D4D4;
  padding: 25px;
  width: 92px;
  margin: 0 auto;
}

.inner-test {
  background: #ADADAD;
  padding: 46px;
  width: 0;
}
</style>

<div class="outer-test"><div class="inner-test"></div></div>

<p><button class="btn clear-log-2">Clear log</button></p>
<p><textarea class="log-output log-output-2" readonly></textarea></p>
<script>
var targetLogOutput;

function log2(str) {
  console.log(str);
  var el;

  if (jsActivatedClick) {
    el = document.querySelector('.log-output-3');
  }
  else {
    el = document.querySelector('.log-output-2');
  }
  el.value += (el.value ? '\n' : '') + str;
}

document.querySelector('.clear-log-2').addEventListener('click', function() {
  document.querySelector('.log-output-2').value = '';
});

// Let's get hold of those elements
var outer = document.querySelector('.outer-test');
var inner = document.querySelector('.inner-test');

// Let's listen for attribute changes on the
// outer element
new MutationObserver(function() {
  log2('mutate');
}).observe(outer, {
  attributes: true
});

// Here's a click listener…
function onClick() {
  log2('click');

  setTimeout(function() {
    log2('timeout');
  },0);

  Promise.resolve().then(function() {
    log2('promise');
  });

  outer.setAttribute('data-random', Math.random());
}

// …which we'll attach to both elements
inner.addEventListener('click', onClick);
outer.addEventListener('click', onClick);
</script>

<p>Was your guess different? If so, you may still be right. Unfortunately the browsers don't really agree here:</p>
<style>
.browser-results {
  display: flex;
  display: -webkit-flex;
  justify-content: center;
  -webkit-justify-content: center;
  margin: 0;
  padding: 0;
  font-family: Inconsolata, monospace;
}

.browser-results li {
  display: block;
  margin: 0;
  padding: 0;
}

.browser-results > li {
  margin-left: 1px;
  background: #eee;
  padding: 0.5rem;
  padding-bottom: 0.4rem;
  line-height: 1.5;
}

@media (min-width: 400px) {
  .browser-results > li {
    margin-left: 1rem;
  }
}

.browser-results > li:first-child {
  margin-left: 0;
}

.browser-results ul {
  display: block;
  margin: 0;
  padding: 0;
}

.browser-results img {
  width: 100%;
  max-width: 100px;
}
</style>

<section>
  <ul class="browser-results">
    <li>
      <img src="/static/imgs/browser-icons/chrome.041e39c7c6f7.png" alt="Chrome">
      <ul>
        <li>click</li>
        <li>promise</li>
        <li>mutate</li>
        <li>click</li>
        <li>promise</li>
        <li>mutate</li>
        <li>timeout</li>
        <li>timeout</li>
      </ul>
    </li>
    <li>
      <img src="/static/imgs/browser-icons/firefox.6d8bb8468f8d.png" alt="Firefox">
      <ul>
        <li>click</li>
        <li>mutate</li>
        <li>click</li>
        <li>mutate</li>
        <li>timeout</li>
        <li>promise</li>
        <li>promise</li>
        <li>timeout</li>
      </ul>
    </li>
    <li>
      <img src="/static/imgs/browser-icons/safari.db3455e864d0.png" alt="Safari">
      <ul>
        <li>click</li>
        <li>mutate</li>
        <li>click</li>
        <li>mutate</li>
        <li>promise</li>
        <li>promise</li>
        <li>timeout</li>
        <li>timeout</li>
      </ul>
    </li>
    <li>
      <img src="/static/imgs/browser-icons/edge.1b9de1f3baec.png" alt="Edge">
      <ul>
        <li>click</li>
        <li>click</li>
        <li>mutate</li>
        <li>timeout</li>
        <li>promise</li>
        <li>timeout</li>
        <li>promise</li>
      </ul>
    </li>
  </ul>
</section>

<h2 id="whos-right">Who's right?</h2>
<p>Dispatching the 'click' event is a task. Mutation observer and promise callbacks are queued as microtasks. The <code>setTimeout</code> callback is queued as a task. So here's how it goes:</p>
<div class="event-loop-walkthrough event-loop-walkthrough-2">
  <div class="js-source">
    <div class="line-highlight"></div>
<div class="codehilite"><pre><span class="c1">// Let's get hold of those elements</span>
<span class="kd">var</span> <span class="nx">outer</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="s1">'.outer'</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">inner</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="s1">'.inner'</span><span class="p">);</span>

<span class="c1">// Let's listen for attribute changes on the</span>
<span class="c1">// outer element</span>
<span class="k">new</span> <span class="nx">MutationObserver</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'mutate'</span><span class="p">);</span>
<span class="p">}).</span><span class="nx">observe</span><span class="p">(</span><span class="nx">outer</span><span class="p">,</span> <span class="p">{</span>
  <span class="nx">attributes</span><span class="o">:</span> <span class="kc">true</span>
<span class="p">});</span>

<span class="c1">// Here's a click listener…</span>
<span class="kd">function</span> <span class="nx">onClick</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'click'</span><span class="p">);</span>

  <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'timeout'</span><span class="p">);</span>
  <span class="p">},</span> <span class="mi">0</span><span class="p">);</span>

  <span class="nx">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">().</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'promise'</span><span class="p">);</span>
  <span class="p">});</span>

  <span class="nx">outer</span><span class="p">.</span><span class="nx">setAttribute</span><span class="p">(</span><span class="s1">'data-random'</span><span class="p">,</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">random</span><span class="p">());</span>
<span class="p">}</span>

<span class="c1">// …which we'll attach to both elements</span>
<span class="nx">inner</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s1">'click'</span><span class="p">,</span> <span class="nx">onClick</span><span class="p">);</span>
<span class="nx">outer</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s1">'click'</span><span class="p">,</span> <span class="nx">onClick</span><span class="p">);</span>
</pre></div>

<p></div>
  <table>
    <tr class="task-queue">
      <th>Tasks</th>
      <td>
        <div class="event-loop-items">
          <div class="event-loop-rail">
            <div class="event-loop-item">Dispatch click</div>
            <div class="event-loop-item">setTimeout callback</div>
            <div class="event-loop-item">setTimeout callback</div>
          </div>
        </div>
      </td>
    </tr>
    <tr class="microtask-queue">
      <th>Microtasks</th>
      <td>
        <div class="event-loop-items">
          <div class="event-loop-rail">
            <div class="event-loop-item">Promise then</div>
            <div class="event-loop-item">Mutation observers</div>
            <div class="event-loop-item">Promise then</div>
            <div class="event-loop-item">Mutation observers</div>
          </div>
        </div>
      </td>
    </tr>
    <tr class="js-stack">
      <th>JS stack</th>
      <td>
        <div class="event-loop-items"></div>
      </td>
    </tr>
    <tr class="event-loop-log">
      <th>Log</th>
      <td>
        <div class="event-loop-items">
          <div class="event-loop-item">click</div>
          <div class="event-loop-item">promise</div>
          <div class="event-loop-item">mutate</div>
          <div class="event-loop-item">click</div>
          <div class="event-loop-item">promise</div>
          <div class="event-loop-item">mutate</div>
          <div class="event-loop-item">timeout</div>
          <div class="event-loop-item">timeout</div>
        </div>
      </td>
    </tr>
  </table>
  <div class="event-loop-controls">
    <svg viewBox="0 0 5 2">
      <path d="M2,0 L2,2 L0,1 z" />
      <path d="M3,0 L5,1 L3,2 z" />
      <path class="prev-btn" d="M0,0 H2.5V2H0z" />
      <path class="next-btn" d="M2.5,0 H5V2H2.5z" />
    </svg>
  </div>
  <div class="event-loop-commentary">
    <div class="event-loop-commentary-item"></div>
  </div>
</div></p>
<script>
new EventLoopAnimation(document.querySelector('.event-loop-walkthrough-2'))
  .state().pushTask(true)
  .state().moveToLine(15).pushStack('onClick').showCodeBar()
  .state().pushLog()
  .state().moveToLine(17)
  .state().pushTask()
  .state().moveToLine(21)
  .state().pushMicrotask()
  .state().moveToLine(25)
  .state().commentary("This mutation queues a microtask to handle observers")
  .state().hideCommentary().pushMicrotask()
  .state().hideCodeBar().popStack()
  .state().commentary("Although we're mid-task, microtasks are processed after callbacks if the stack is empty")
  .state().hideCommentary().activateMicrotask()
  .state().showCodeBar().moveToLine(22).pushStack('Promise callback')
  .state().pushLog()
  .state().hideCodeBar().popStack().shiftMicrotask().activateMicrotask()
  .state().showCodeBar().moveToLine(8).pushStack('Mutation callback')
  .state().pushLog()
  .state().hideCodeBar().popStack().shiftMicrotask()
  .state().commentary("The event bubbles, so our callback is called again for the outer element")
  .state().hideCommentary().moveToLine(15).pushStack('onClick').showCodeBar()
  .state().pushLog()
  .state().moveToLine(17)
  .state().pushTask()
  .state().moveToLine(21)
  .state().pushMicrotask()
  .state().moveToLine(25)
  .state().pushMicrotask()
  .state().hideCodeBar().popStack()
  .state().activateMicrotask()
  .state().showCodeBar().moveToLine(22).pushStack('Promise callback')
  .state().pushLog()
  .state().hideCodeBar().popStack().shiftMicrotask().activateMicrotask()
  .state().showCodeBar().moveToLine(8).pushStack('Mutation callback')
  .state().pushLog()
  .state().hideCodeBar().popStack().shiftMicrotask()
  .state().shiftTask().activateTask()
  .state().showCodeBar().moveToLine(18).pushStack('setTimeout callback')
  .state().pushLog()
  .state().popStack().hideCodeBar().shiftTask().activateTask()
  .state().showCodeBar().pushStack('setTimeout callback')
  .state().pushLog()
  .state().popStack().hideCodeBar().shiftTask()
  .state().commentary('fin')
  ;
</script>

<p>So it's Chrome that gets it right. The bit that was 'news to me' is that microtasks are processed after callbacks (as long as no other JavaScript is mid-execution), I thought it was limited to end-of-task. This rule comes from the HTML spec for calling a callback:</p>
<blockquote class="quote"><p>If the <a href="https://html.spec.whatwg.org/multipage/webappapis.html#stack-of-script-settings-objects">stack of script settings objects</a> is now empty, <a href="https://html.spec.whatwg.org/multipage/webappapis.html#perform-a-microtask-checkpoint">perform a microtask checkpoint</a></p>&mdash; <a href="https://html.spec.whatwg.org/multipage/webappapis.html#clean-up-after-running-a-callback">HTML: Cleaning up after a callback</a> step 3</blockquote>

<p>…and a microtask checkpoint involves going through the microtask queue, unless we're already processing the microtask queue. Similarly, ECMAScript says this of jobs:</p>
<blockquote class="quote"><p>Execution of a Job can be initiated only when there is no running execution context and the execution context stack is empty…</p>&mdash; <a href="https://www.ecma-international.org/ecma-262/6.0/#sec-jobs-and-job-queues">ECMAScript: Jobs and Job Queues</a></blockquote>

<p>…although the "can be" becomes "must be" when in an HTML context.</p>
<h2 id="what-did-browsers-get-wrong">What did browsers get wrong?</h2>
<p><strong>Firefox</strong> and <strong>Safari</strong> are correctly exhausting the microtask queue between click listeners, as shown by the mutation callbacks, but promises appear to be queued differently. This is sort-of excusable given that the link between jobs &amp; microtasks is vague, but I'd still expect them to execute between listener callbacks. <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1193394">Firefox ticket</a>. <a href="https://bugs.webkit.org/show_bug.cgi?id=147933">Safari ticket</a>.</p>
<p>With <strong>Edge</strong> we've already seen it queue promises incorrectly, but it also fails to exhaust the microtask queue between click listeners, instead it does so after calling all listeners, which accounts for the single <code>mutate</code> log after both <code>click</code> logs. <a href="https://connect.microsoft.com/IE/feedbackdetail/view/1658386/microtasks-queues-should-be-processed-following-event-listeners">Bug ticket</a>.</p>
<h2 id="level-1-bosss-angry-older-brother">Level 1 boss's angry older brother</h2>
<p>Ohh boy. Using the same example from above, what happens if we execute:</p>
<div class="codehilite"><pre><span class="nx">inner</span><span class="p">.</span><span class="nx">click</span><span class="p">();</span>
</pre></div>


<p>This will start the event dispatching as before, but using script rather than a real interaction.</p>
<h2 id="try-it_1">Try it</h2>
<p><button class="btn clear-log-3">Clear log</button> <button class="btn test-2">Run test</button></p>
<p><textarea class="log-output log-output-3" readonly></textarea></p>
<script>
var jsActivatedClick = false;
document.querySelector('.test-2').addEventListener('click', function() {
  jsActivatedClick = true;
  inner.click();
  setTimeout(function() {
    jsActivatedClick = false;
  }, 100);
});
document.querySelector('.clear-log-3').addEventListener('click', function() {
  document.querySelector('.log-output-3').value = '';
});
</script>

<p>And here's what the browsers say:</p>
<section>
  <ul class="browser-results">
    <li>
      <img src="/static/imgs/browser-icons/chrome.041e39c7c6f7.png" alt="Chrome">
      <ul>
        <li>click</li>
        <li>click</li>
        <li>promise</li>
        <li>mutate</li>
        <li>promise</li>
        <li>timeout</li>
        <li>timeout</li>
      </ul>
    </li>
    <li>
      <img src="/static/imgs/browser-icons/firefox.6d8bb8468f8d.png" alt="Firefox">
      <ul>
        <li>click</li>
        <li>click</li>
        <li>mutate</li>
        <li>timeout</li>
        <li>promise</li>
        <li>promise</li>
        <li>timeout</li>
      </ul>
    </li>
    <li>
      <img src="/static/imgs/browser-icons/safari.db3455e864d0.png" alt="Safari">
      <ul>
        <li>click</li>
        <li>click</li>
        <li>mutate</li>
        <li>promise</li>
        <li>promise</li>
        <li>timeout</li>
        <li>timeout</li>
      </ul>
    </li>
    <li>
      <img src="/static/imgs/browser-icons/edge.1b9de1f3baec.png" alt="Edge">
      <ul>
        <li>click</li>
        <li>click</li>
        <li>mutate</li>
        <li>timeout</li>
        <li>promise</li>
        <li>timeout</li>
        <li>promise</li>
      </ul>
    </li>
  </ul>
</section>

<p>And I swear I keep getting different results from Chrome, I've updated this chart a ton of times thinking I was testing Canary by mistake. If you get different results in Chrome, tell me which version in the comments.</p>
<h2 id="why-is-it-different">Why is it different?</h2>
<p>Here's how it should happen:</p>
<div class="event-loop-walkthrough event-loop-walkthrough-3">
  <div class="js-source">
    <div class="line-highlight"></div>
<div class="codehilite"><pre><span class="c1">// Let's get hold of those elements</span>
<span class="kd">var</span> <span class="nx">outer</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="s1">'.outer'</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">inner</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="s1">'.inner'</span><span class="p">);</span>

<span class="c1">// Let's listen for attribute changes on the</span>
<span class="c1">// outer element</span>
<span class="k">new</span> <span class="nx">MutationObserver</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'mutate'</span><span class="p">);</span>
<span class="p">}).</span><span class="nx">observe</span><span class="p">(</span><span class="nx">outer</span><span class="p">,</span> <span class="p">{</span>
  <span class="nx">attributes</span><span class="o">:</span> <span class="kc">true</span>
<span class="p">});</span>

<span class="c1">// Here's a click listener…</span>
<span class="kd">function</span> <span class="nx">onClick</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'click'</span><span class="p">);</span>

  <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'timeout'</span><span class="p">);</span>
  <span class="p">},</span> <span class="mi">0</span><span class="p">);</span>

  <span class="nx">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">().</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'promise'</span><span class="p">);</span>
  <span class="p">});</span>

  <span class="nx">outer</span><span class="p">.</span><span class="nx">setAttribute</span><span class="p">(</span><span class="s1">'data-random'</span><span class="p">,</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">random</span><span class="p">());</span>
<span class="p">}</span>

<span class="c1">// …which we'll attach to both elements</span>
<span class="nx">inner</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s1">'click'</span><span class="p">,</span> <span class="nx">onClick</span><span class="p">);</span>
<span class="nx">outer</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s1">'click'</span><span class="p">,</span> <span class="nx">onClick</span><span class="p">);</span>

<span class="nx">inner</span><span class="p">.</span><span class="nx">click</span><span class="p">();</span>
</pre></div>

<p></div>
  <table>
    <tr class="task-queue">
      <th>Tasks</th>
      <td>
        <div class="event-loop-items">
          <div class="event-loop-rail">
            <div class="event-loop-item">Run script</div>
            <div class="event-loop-item">setTimeout callback</div>
            <div class="event-loop-item">setTimeout callback</div>
          </div>
        </div>
      </td>
    </tr>
    <tr class="microtask-queue">
      <th>Microtasks</th>
      <td>
        <div class="event-loop-items">
          <div class="event-loop-rail">
            <div class="event-loop-item">Promise then</div>
            <div class="event-loop-item">Mutation observers</div>
            <div class="event-loop-item">Promise then</div>
          </div>
        </div>
      </td>
    </tr>
    <tr class="js-stack">
      <th>JS stack</th>
      <td>
        <div class="event-loop-items"></div>
      </td>
    </tr>
    <tr class="event-loop-log">
      <th>Log</th>
      <td>
        <div class="event-loop-items">
          <div class="event-loop-item">click</div>
          <div class="event-loop-item">click</div>
          <div class="event-loop-item">promise</div>
          <div class="event-loop-item">mutate</div>
          <div class="event-loop-item">promise</div>
          <div class="event-loop-item">timeout</div>
          <div class="event-loop-item">timeout</div>
        </div>
      </td>
    </tr>
  </table>
  <div class="event-loop-controls">
    <svg viewBox="0 0 5 2">
      <path d="M2,0 L2,2 L0,1 z" />
      <path d="M3,0 L5,1 L3,2 z" />
      <path class="prev-btn" d="M0,0 H2.5V2H0z" />
      <path class="next-btn" d="M2.5,0 H5V2H2.5z" />
    </svg>
  </div>
  <div class="event-loop-commentary">
    <div class="event-loop-commentary-item"></div>
  </div>
</div></p>
<script>
new EventLoopAnimation(document.querySelector('.event-loop-walkthrough-3'))
  .state().pushTask(true).pushStack('script')
  .state().moveToLine(32).showCodeBar()
  .state().moveToLine(15).pushStack('onClick')
  .state().pushLog()
  .state().moveToLine(17)
  .state().pushTask()
  .state().moveToLine(21)
  .state().pushMicrotask()
  .state().moveToLine(25)
  .state().pushMicrotask()
  .state().hideCodeBar().popStack()
  .state().commentary("We cannot process microtasks, the stack is not empty")
  .state().hideCommentary()
  .state().moveToLine(15).showCodeBar().pushStack('onClick')
  .state().pushLog()
  .state().moveToLine(17)
  .state().pushTask()
  .state().moveToLine(21)
  .state().pushMicrotask()
  .state().moveToLine(25)
  .state().commentary("We don't add another mutation microtask as one is already pending")
  .state().hideCommentary().hideCodeBar().popStack()
  .state().moveToLine(32).showCodeBar()
  .state().hideCodeBar().popStack()
  .state().commentary("We're at the end of this task, so now we can process microtasks")
  .state().hideCommentary().activateMicrotask()
  .state().showCodeBar().moveToLine(22).pushStack('Promise callback')
  .state().pushLog()
  .state().hideCodeBar().popStack().shiftMicrotask().activateMicrotask()
  .state().showCodeBar().moveToLine(8).pushStack('Mutation callback')
  .state().pushLog()
  .state().hideCodeBar().popStack().shiftMicrotask().activateMicrotask()
  .state().showCodeBar().moveToLine(22).pushStack('Promise callback')
  .state().pushLog()
  .state().hideCodeBar().popStack().shiftMicrotask()
  .state().shiftTask().activateTask()
  .state().showCodeBar().moveToLine(18).pushStack('setTimeout callback')
  .state().pushLog()
  .state().popStack().hideCodeBar().shiftTask().activateTask()
  .state().showCodeBar().pushStack('setTimeout callback')
  .state().pushLog()
  .state().popStack().hideCodeBar().shiftTask()
  .state().commentary('fin')
  ;
</script>


  </div>

    </div>
  </body>
</html>